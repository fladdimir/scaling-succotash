!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).VueColorPicker = e() }(this, (function () { "use strict"; const t = 180 / Math.PI, e = t => { const e = t % 360; return e < 0 ? 360 + e : e }, i = () => { }; class s { constructor(t, e) { this.active = !1, this.element = t, this.element.style.willChange = "transform", this.initOptions(e), this.updateCSS(), this.bindHandlers(), this.addListeners() } get angle() { return this._angle } set angle(t) { this._angle !== t && (this._angle = e(t), this.updateCSS()) } initOptions(t) { t = t || {}, this.onRotate = t.onRotate || i, this.onDragStart = t.onDragStart || i, this.onDragStop = t.onDragStop || i, this._angle = t.angle || 0 } bindHandlers() { this.onRotationStart = this.onRotationStart.bind(this), this.onRotated = this.onRotated.bind(this), this.onRotationStop = this.onRotationStop.bind(this) } addListeners() { this.element.addEventListener("touchstart", this.onRotationStart, { passive: !0 }), document.addEventListener("touchmove", this.onRotated, { passive: !1 }), document.addEventListener("touchend", this.onRotationStop, { passive: !0 }), document.addEventListener("touchcancel", this.onRotationStop, { passive: !0 }), this.element.addEventListener("mousedown", this.onRotationStart, { passive: !0 }), document.addEventListener("mousemove", this.onRotated, { passive: !1 }), document.addEventListener("mouseup", this.onRotationStop, { passive: !0 }), document.addEventListener("mouseleave", this.onRotationStop, { passive: !1 }) } removeListeners() { this.element.removeEventListener("touchstart", this.onRotationStart), document.removeEventListener("touchmove", this.onRotated), document.removeEventListener("touchend", this.onRotationStop), document.removeEventListener("touchcancel", this.onRotationStop), this.element.removeEventListener("mousedown", this.onRotationStart), document.removeEventListener("mousemove", this.onRotated), document.removeEventListener("mouseup", this.onRotationStop), document.removeEventListener("mouseleave", this.onRotationStop) } destroy() { this.onRotationStop(), this.removeListeners() } onRotationStart(t) { "touchstart" !== t.type && 0 !== t.button || (this.active = !0, this.onDragStart(t), this.setAngleFromEvent(t)) } onRotationStop() { this.active && (this.active = !1, this.onDragStop()), this.active = !1 } onRotated(t) { this.active && (t.preventDefault(), this.setAngleFromEvent(t)) } setAngleFromEvent(i) { const s = i.targetTouches ? i.targetTouches[0] : i, n = (({ x: e, y: i }, s) => { const n = s.left + s.width / 2, o = s.top + s.height / 2; return Math.atan2(i - o, e - n) * t })({ x: s.clientX, y: s.clientY }, this.element.getBoundingClientRect()); this._angle = e(n + 90), this.updateCSS(), this.onRotate(this._angle) } updateCSS() { this.element.style.transform = "rotate(" + this._angle + "deg)" } } const n = ["red", "yellow", "green", "cyan", "blue", "magenta", "red"], o = { ArrowUp: (t, e) => t + e, ArrowRight: (t, e) => t + e, ArrowDown: (t, e) => t - e, ArrowLeft: (t, e) => t - e, PageUp: (t, e) => t + 10 * e, PageDown: (t, e) => t - 10 * e, Home: () => 0, End: () => 359 }; const a = { rcp: null, name: "ColorPicker", props: { hue: { default: 0 }, saturation: { default: 100 }, luminosity: { default: 50 }, alpha: { default: 1 }, step: { default: 1 }, mouseScroll: { default: !1 }, variant: { default: "collapsible" }, disabled: { default: !1 }, initiallyCollapsed: { default: !1 }, ariaLabel: { default: "color picker" }, ariaRoledescription: { default: "radial slider" }, ariaValuetext: { default: "" }, ariaLabelColorWell: { default: "color well" } }, data() { return { angle: 0, ssrHue: 0, isPaletteIn: !this.initiallyCollapsed, isKnobIn: !this.initiallyCollapsed, isPressed: !1, isRippling: !1, isDragging: !1 } }, computed: { color() { return `hsla(${this.angle}, ${this.saturation}%, ${this.luminosity}%, ${this.alpha})` }, valuetext() { return n[Math.round(this.angle / 60)] } }, watch: { hue: function (t) { this.angle = t, this.rcp.angle = t } }, created() { this.ssrHue = this.hue, this.angle = this.ssrHue }, mounted() { getComputedStyle(this.$refs.palette).backgroundImage.includes("conic") || function (t, e) { const i = e / 2, s = Math.sqrt(2) * i, n = Math.PI / 180, o = 2 * Math.PI; t.width = t.height = e; const a = t.getContext("2d"), r = .5 * n + .02; a.translate(i, i), a.rotate(-Math.PI / 2), a.translate(-i, -i); for (let t = 0; t < 360; t += .5) { a.fillStyle = "hsl(" + t + ", 100%, 50%)", a.beginPath(), a.moveTo(i, i); const e = t * n, l = Math.min(o, e + r); a.arc(i, i, s, e, l), a.closePath(), a.fill() } }(this.$refs.palette.firstElementChild, this.$el.offsetWidth || 280), this.rcp = new s(this.$refs.rotator, { angle: this.angle, onRotate: t => { this.angle = t, this.$emit("input", this.angle) }, onDragStart: () => { this.isDragging = !0 }, onDragStop: () => { this.isDragging = !1, this.$emit("change", this.angle) } }) }, methods: { onKeyDown(t) { !this.disabled && !this.isPressed && this.isKnobIn && t.key in o && (t.preventDefault(), this.rcp.angle = o[t.key](this.rcp.angle, this.step), this.angle = this.rcp.angle, this.$emit("input", this.angle), this.$emit("change", this.angle)) }, onScroll(t) { !this.isPressed && this.isKnobIn && (t.preventDefault(), t.deltaY > 0 ? this.rcp.angle += this.step : this.rcp.angle -= this.step, this.angle = this.rcp.angle, this.$emit("input", this.angle), this.$emit("change", this.angle)) }, selectColor() { this.isPressed = !0, this.isPaletteIn && this.isKnobIn ? (this.$emit("select", this.angle), this.isRippling = !0) : this.isPaletteIn = !0 }, togglePicker() { "persistent" !== this.variant && (this.isKnobIn ? this.isKnobIn = !1 : (this.isKnobIn = !0, this.isPaletteIn = !0)), this.isRippling = !1, this.isPressed = !1 }, hidePalette() { this.isKnobIn || (this.isPaletteIn = !1) } }, beforeDestroy() { this.rcp.destroy(), this.rcp = null } }; var r = function () { var t = this, e = t.$createElement, i = t._self._c || e; return i("div", { staticClass: "rcp", class: { dragging: t.isDragging, disabled: t.disabled }, attrs: { role: "slider", "aria-roledescription": t.ariaRoledescription, "aria-label": t.ariaLabel, "aria-expanded": t.isPaletteIn ? "true" : "false", "aria-valuemin": "0", "aria-valuemax": "359", "aria-valuenow": t.angle, "aria-valuetext": t.ariaValuetext || t.valuetext, "aria-disabled": t.disabled ? "true" : "false", tabindex: t.disabled ? -1 : 0 }, on: { keyup: function (e) { return !e.type.indexOf("key") && t._k(e.keyCode, "enter", 13, e.key, "Enter") ? null : t.selectColor(e) }, keydown: t.onKeyDown } }, [i("div", { ref: "palette", staticClass: "rcp__palette", class: t.isPaletteIn ? "in" : "out" }, [i("canvas")]), t._v(" "), i("div", t._g({ ref: "rotator", staticClass: "rcp__rotator", style: { "pointer-events": t.disabled || t.isPressed || !t.isKnobIn ? "none" : null, transform: "rotate(" + t.ssrHue + "deg)" } }, t.mouseScroll ? { wheel: t.onScroll } : null), [i("div", { staticClass: "rcp__knob", class: t.isKnobIn ? "in" : "out", on: { transitionend: t.hidePalette } })]), t._v(" "), i("div", { staticClass: "rcp__ripple", class: { rippling: t.isRippling }, style: { borderColor: t.color } }), t._v(" "), i("button", { staticClass: "rcp__well", class: { pressed: t.isPressed }, style: { backgroundColor: t.color }, attrs: { type: "button", "aria-label": t.ariaLabelColorWell, disabled: t.disabled, tabindex: t.disabled ? -1 : 0 }, on: { animationend: t.togglePicker, click: t.selectColor } })]) }; r._withStripped = !0; const l = function (t, e, i, s, n, o, a, r, l, h) { "boolean" != typeof a && (l = r, r = a, a = !1); const d = "function" == typeof i ? i.options : i; let c; if (t && t.render && (d.render = t.render, d.staticRenderFns = t.staticRenderFns, d._compiled = !0, n && (d.functional = !0)), s && (d._scopeId = s), o ? (c = function (t) { (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), e && e.call(this, l(t)), t && t._registeredComponents && t._registeredComponents.add(o) }, d._ssrRegister = c) : e && (c = a ? function (t) { e.call(this, h(t, this.$root.$options.shadowRoot)) } : function (t) { e.call(this, r(t)) }), c) if (d.functional) { const t = d.render; d.render = function (e, i) { return c.call(i), t(e, i) } } else { const t = d.beforeCreate; d.beforeCreate = t ? [].concat(t, c) : [c] } return i }({ render: r, staticRenderFns: [] }, void 0, a, void 0, !1, void 0, !1, void 0, void 0, void 0); return l.install = function (t) { t.component("ColorPicker", l) }, l }));
